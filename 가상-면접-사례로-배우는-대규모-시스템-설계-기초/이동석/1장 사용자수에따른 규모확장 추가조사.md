## 1. 비관계형 데이터베이스(NoSQL)의 필요성

관계형 데이터베이스(RDBMS)는 데이터 정합성이 뛰어나지만, 조인(Join) 연산의 비용과 확장성 문제로 인해 아래와 같은 상황에서는 NoSQL이 권장됩니다.

- **아주 낮은 응답 지연:** 마이크로초 단위의 처리가 필요한 경우.
- **비정형 데이터:** 고정된 스키마가 없는 소셜 미디어 포스트, 로그 데이터 등.
- **대규모 데이터:** 단일 서버의 한계를 넘어서는 테라~페타바이트급 데이터.

---

## 2. 성능 지표 비교: MySQL vs Redis

저장 매체의 차이가 응답 속도의 근본적인 차이를 만듭니다.

| **구분** | **MySQL (RDBMS)** | **Redis (In-Memory)** |
| --- | --- | --- |
| **저장 매체** | 디스크 (SSD/HDD) | 메인 메모리 (RAM) |
| **응답 지연** | 밀리초(ms) 단위 | 마이크로초(μs) 단위 |
| **수치 예시** | 1ms ~ 50ms | 100μs ~ 500μs (0.1ms ~ 0.5ms) |

> Insight: Redis는 MySQL보다 약 10배에서 100배 빠른 응답 속도를 제공합니다. 따라서 세션 관리, 캐싱, 실시간 랭킹 등에 주로 사용됩니다.
>

---

## 3. 데이터 규모 및 확장성: MySQL vs MongoDB

두 시스템 모두 데이터 총량은 "무제한"에 가깝지만, 이를 처리하는 방식(확장 전략)에서 큰 차이를 보입니다.

### **핵심 비교**

- **단일 레코드 제한:** MySQL은 행(Row)당 약 **64KB**로 엄격한 편이나, MongoDB는 문서(Document)당 **16MB**로 훨씬 넉넉합니다.
- **확장 방식:**
    - **MySQL:** 주로 **수직 확장(Scale-up)**에 의존하며, 샤딩 구현 시 복잡도가 높습니다.
    - **MongoDB:** 처음부터 **수평 확장(Scale-out, Sharding)**을 염두에 두고 설계되어 대규모 클러스터 구축에 유리합니다.
- **저장 효율:** MySQL은 정해진 규격에 맞춰 저장하므로 공간 효율이 좋고, MongoDB는 필드명을 포함해 저장(BSON)하므로 오버헤드가 있으나 압축 엔진(WiredTiger)으로 이를 보완합니다.

---

## 4. 수평 분할의 핵심: 샤딩(Sharding)

데이터 양이 많아져 단일 서버로 감당이 안 될 때, 데이터를 여러 서버(샤드)에 쪼개어 저장하는 기술입니다.

### **샤드 키(Shard Key)와 인덱스(Index)**

샤딩 컬럼에 인덱스를 설정하는 것은 **선택이 아닌 필수**입니다.

1. **라우팅 속도:** 쿼리가 들어왔을 때 어느 서버로 보낼지 결정하는 '내비게이션' 역할을 합니다. 인덱스가 없으면 모든 서버를 전수 조사해야 합니다.
2. **샤드 내 검색 효율:** 개별 서버에 도달한 후에도 데이터 검색 속도를 보장해야 합니다.
3. **제약 조건:** 많은 분산 DB에서 샤드 키를 Primary Key나 Unique Key의 일부로 포함하도록 강제합니다.

### **샤드 키 선정 시 체크리스트**

- **분산(Distribution):** 데이터가 특정 샤드에 몰리는 **Hotspot 현상**이 없는가?
- **패턴(Query Pattern):** 가장 자주 사용되는 조회 조건인가?
- **불변성(Immutability):** 값이 자주 바뀌어 데이터 이동 부하를 일으키지 않는가?

---

**레퍼런스 모음**

- [MySQL vs Redis Performance Comparison](https://dkomanov.medium.com/mysql-as-redis-vs-redis-74b788af9c6f)

## 5. mysql의 샤딩

**MySQL은 데이터베이스 엔진 차원에서 '기본(Native)'으로 제공하는 자동 샤딩 기능이 없습니다.** 반면, MongoDB는 처음부터 수평적 확장을 고려해 설계되었기 때문에 '샤드 클러스터'라는 이름으로 샤딩을 기본 지원합니다.

MySQL에서 샤딩을 구현하려면 말씀하신 대로 **추가적인 기술이나 아키텍처 설계**가 반드시 필요합니다.

---

### 1. MySQL과 MongoDB의 샤딩 차이

| **구분** | **MySQL (RDBMS)** | **MongoDB (NoSQL)** |
| --- | --- | --- |
| **샤딩 지원** | **기본 지원 안 함** (수동 구현 필요) | **기본 지원** (Native Sharding) |
| **확장 방식** | 주로 수직 확장(Scale-up) 및 복제본(Read Replica) 활용 | 수평 확장(Scale-out) 중심 |
| **관리 주체** | 개발자나 DBA가 샤딩 로직 직접 관리 | DB 엔진(Config Server, Mongos)이 자동 관리 |

---

### 2. MySQL에서 샤딩을 하기 위한 방법 (추가 기술)

MySQL을 샤딩하려면 데이터가 어느 서버에 있는지 찾아주는 **'중간 계층(Middleware)'**이나 **'애플리케이션 로직'**이 필요합니다.

### ① 미들웨어 활용 (가장 권장되는 방식)

DB와 애플리케이션 사이에서 쿼리를 적절한 샤드로 보내주는 솔루션을 사용합니다.

- **Vitess:** 유튜브(YouTube)를 위해 개발된 기술로, MySQL을 클라우드 네이티브 환경에서 샤딩할 수 있게 해주는 가장 강력한 도구입니다.
- **ProxySQL:** 데이터베이스 프로토콜 수준에서 쿼리 룰을 설정하여 특정 조건에 따라 여러 DB로 쿼리를 분산(Routing)합니다.
- **ShardingSphere:** 자바 생태계에서 유명하며, 애플리케이션과 DB 사이에서 샤딩, 읽기/쓰기 분리 등을 처리합니다.

### ② 애플리케이션 레벨 샤딩

미들웨어 없이 **서비스 코드 내부에서** 샤딩 로직을 직접 구현하는 방식입니다.

- 예: `user_id % 4` 결과가 0이면 A서버, 1이면 B서버로 접속하도록 코딩합니다.
- **단점:** 관리가 매우 어렵고, 샤드를 추가(Resharding)할 때마다 코드를 수정하고 데이터를 옮기는 작업이 매우 고통스럽습니다.

### ③ MySQL Cluster (NDB Cluster)

MySQL에서 공식적으로 제공하는 클러스터링 솔루션이 있지만, 설정이 매우 복잡하고 일반적인 MySQL(InnoDB)과는 특성이 달라 범용적으로 쓰이지는 않습니다.

---

### 3. 요약

- **MySQL:** 샤딩이 기본 기능이 아니므로 **Vitess, ProxySQL** 같은 외부 도구를 쓰거나, 직접 고생해서 코드로 짜야 합니다.
- **MongoDB:** **'Shard Key'**만 지정하면 DB가 알아서 데이터를 쪼개고 분산해 줍니다.

## 6. mysql의 파티셔닝

MySQL의 **파티셔닝(Partitioning)**은 쉽게 말해 **"하나의 커다란 테이블을 관리하기 편하게 여러 개의 작은 물리적 단위로 쪼개는 기술"**입니다.

이전 질문에서 다룬 '샤딩'과 가장 큰 차이점은 **데이터가 여전히 하나의 MySQL 서버(또는 인스턴스) 안에 머문다는 점**입니다. 사용자 입장에서는 하나의 테이블처럼 보이지만, 실제 디스크 저장소에서는 데이터가 여러 파일로 분리되어 저장됩니다.

---

### 1. 파티셔닝과 샤딩 비교

이 개념을 혼동하기 쉬운데, 그림으로 이해하면 명확합니다.

- **파티셔닝:** 한 아파트(서버) 안에서 방을 여러 개로 나누어 짐을 정리하는 것 (서버 1대 유지)
- **샤딩:** 짐이 너무 많아져서 아예 옆 동이나 다른 아파트(서버)로 짐을 옮기는 것 (서버 여러 대 확장)

---

### 2. 왜 파티셔닝을 쓰나요? (주요 장점)

1. **쿼리 성능 향상 (Partition Pruning):** 예를 들어 10년치 로그 데이터가 있는 테이블에서 `2024년 1월` 데이터만 조회할 때, MySQL은 다른 연도의 파티션은 아예 쳐다보지도 않고 해당 파티션만 뒤집니다. 이를 '파티션 프루닝'이라고 합니다.
2. **데이터 관리 용이성:** 오래된 데이터를 지울 때 `DELETE FROM...` 쿼리를 날리면 DB에 부하가 크고 시간이 오래 걸리지만, 파티셔닝이 되어 있다면 그냥 해당 파티션 파일을 **통째로 삭제(Drop)**하면 되므로 눈 깜짝할 새 정리가 끝납니다.
3. **백업 및 복구:** 특정 파티션만 따로 백업하거나 복구할 수 있어 대용량 데이터를 다룰 때 유리합니다.

---

### 3. MySQL 파티셔닝의 종류

| **방식** | **설명** | **예시** |
| --- | --- | --- |
| **Range (범위)** | 특정 컬럼의 값 범위를 기준으로 분할 | 날짜(연도별, 월별), 가격대별 |
| **List (목록)** | 미리 정해진 값 목록을 기준으로 분할 | 지역코드(서울, 부산), 부서코드 |
| **Hash (해시)** | 해시 함수를 이용해 데이터를 균등하게 분산 | 특정 컬럼 값을 n개로 균등 배분 |
| **Key (키)** | Hash와 유사하나 MySQL 자체 해시 함수 사용 | PK나 Unique Key 기준 분산 |

---

### 4. 주의사항 (제약 사항)

- **Unique Key 제약:** 테이블에 PK나 Unique Key가 있다면, **파티션 키(기준이 되는 컬럼)는 반드시 이 키들에 포함**되어야 합니다. 그렇지 않으면 생성 자체가 안 됩니다.
- **외래 키(FK) 사용 불가:** 파티셔닝된 테이블에서는 Foreign Key를 사용할 수 없습니다.
- **인덱스 관리:** 모든 파티션에 대해 인덱스가 물리적으로 분리되므로, 조회 조건에 파티션 키가 빠지면 모든 파티션을 다 뒤져야 해서 일반 테이블보다 훨씬 느려질 수 있습니다.

**결론적으로,** MySQL에서 샤딩은 서버를 늘려 '쓰기 부하'를 분산하는 목적이 크고, 파티셔닝은 서버 내에서 '조회 성능'을 높이고 '관리'를 편하게 하는 목적이 큽니다.