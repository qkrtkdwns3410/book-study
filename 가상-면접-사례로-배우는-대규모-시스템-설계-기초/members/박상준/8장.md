## 티켓 서버를 이용한 ID 생성

- 대부분의 어느정도 규모있는 회사들은 티켓 서버를 이용해 채번을 한다.
    - XX 회사도 고객번호를 그런식으로 채번해서 사용함.
- SPOF 리스크
    - 채번 서버가 장애가 나는 경우, 전체 고객번호가 발급이 안될 것이다.
    - failover 야 될 수 있겠지만, 실제로 트위터 스노우 플레이크같은 그런 아키텍처는 없을듯
    - 사실 고객자체는 그정도는 안될거같긴하다

## ULID ( Universally Unique Lexicographically Sortable Identifier )

- UUID 단점과 스노플레이크 장점 결합하여 2016년에 만들어짐
- UUID 단점
    - 시간순 정렬이 불가능함 ( 완전 랜덤 )
    - DB 인덱스 성능이 구림 B-Tree 구조 인덱스에 랜덤하게 삽입되기에..
- 스노플레이크 장점
    - 타임스탬프 기반으로 시간순 정렬이 가능함
    - 시간순 증가하기에 인덱스 끝에만 계속 추가됨 ( 페이지 분할이 X )

```
====================================================================================================
📈 성능 및 스토리지 비교
====================================================================================================

## 생성 성능

### 테스트 조건
- **반복 횟수**: 100,000
- **JVM**: Warmup 1,000회 후 측정
- **환경**: Single-threaded

### 결과
```
ULID 생성: 59.98 ms  (1,667,326 IDs/sec)
UUID 생성: 19.66 ms  (5,086,610 IDs/sec)
```

→ UUID가 3.1x 더 빠름
  (하지만 UUID는 시간순 정렬 불가, DB 인덱스 비효율)

----------------------------------------------------------------------------------------------------

## 스토리지 비교

### 문자열 길이
```
ULID: 26 characters
UUID: 36 characters (32 hex + 4 hyphens)

차이: 10 characters (27.8% 감소)
```

### 바이트 크기 (UTF-8)
```
ULID: 26 bytes
UUID: 36 bytes

차이: 10 bytes (27.8% 감소)
```

### 100만 레코드 기준 예상 스토리지
```
ULID만:                    26,000,000 bytes (24.80 MB)
UUID만:                    36,000,000 bytes (34.33 MB)
UUID + created_at:         44,000,000 bytes (41.96 MB)

절감:                      18,000,000 bytes (17.17 MB, 40.9%)
```

### DB 인덱스 크기 (B-tree, 100만 레코드)
```
ULID:  작음 (순차 삽입, 페이지 스플릿 최소)
UUID:  큼   (랜덤 삽입, 페이지 스플릿 빈번)

예상: ULID 인덱스가 20-30% 더 작음
```

====================================================================================================

====================================================================================================
📊 시간순 정렬 특성 비교
====================================================================================================

## 시나리오: 5개의 주문이 순차적으로 생성됨

### ULID 사용 시

**생성 순서:**
```
[주문 1] 01KH3T3Y274J02E8K6AARG0B1C  (생성: 2026-02-10 21:58:43.143)
[주문 2] 01KH3T3Y2J48PVWJHWCNM6M6R2  (생성: 2026-02-10 21:58:43.154)
[주문 3] 01KH3T3Y2XPTWCXFM3R71YGB59  (생성: 2026-02-10 21:58:43.165)
[주문 4] 01KH3T3Y3AXH2532PEDTNS9ST7  (생성: 2026-02-10 21:58:43.178)
[주문 5] 01KH3T3Y3PPP31R92SM5MAY20D  (생성: 2026-02-10 21:58:43.190)
```

**문자열 정렬 후 (ORDER BY id):**
```
[1] 01KH3T3Y274J02E8K6AARG0B1C  (원래 주문 1)
[2] 01KH3T3Y2J48PVWJHWCNM6M6R2  (원래 주문 2)
[3] 01KH3T3Y2XPTWCXFM3R71YGB59  (원래 주문 3)
[4] 01KH3T3Y3AXH2532PEDTNS9ST7  (원래 주문 4)
[5] 01KH3T3Y3PPP31R92SM5MAY20D  (원래 주문 5)
```
✅ **결과**: 정렬 순서 = 생성 순서 (시간순 정렬 보장!)

----------------------------------------------------------------------------------------------------

### UUID 사용 시

**생성 순서:**
```
[주문 1] 402fb7e5-c539-442e-9d5a-8cd4da358fdd
[주문 2] 44a6f8aa-13cc-459d-b56e-dbbb28c5943b
[주문 3] 7c9ece11-b075-4514-97c7-8a3f1c290b01
[주문 4] 6bb0a704-2a50-45cc-984c-7dddd90ef087
[주문 5] 54d676ea-1642-40ea-b903-424a2cd5059b
```

**문자열 정렬 후 (ORDER BY id):**
```
[1] 402fb7e5-c539-442e-9d5a-8cd4da358fdd  (원래 주문 1)
[2] 44a6f8aa-13cc-459d-b56e-dbbb28c5943b  (원래 주문 2)
[3] 54d676ea-1642-40ea-b903-424a2cd5059b  (원래 주문 5)
[4] 6bb0a704-2a50-45cc-984c-7dddd90ef087  (원래 주문 4)
[5] 7c9ece11-b075-4514-97c7-8a3f1c290b01  (원래 주문 3)
```
❌ **결과**: 정렬 순서 ≠ 생성 순서 (시간순 정렬 불가!)

====================================================================================================

```


- UUID v7 : https://www.rfc-editor.org/rfc/rfc9562.html 표준임
