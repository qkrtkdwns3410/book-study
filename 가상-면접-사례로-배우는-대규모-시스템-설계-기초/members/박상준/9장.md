# 9장 웹 크롤러 시스템 설계

최종 편집 일시: 2026년 2월 16일 오후 3:29

## 크롤러가 차단당하면 어떻게 될까?

### 일단 크롤러가 차단당하는 케이스를 분석해야한다

- 크롤러가 요청 → Cloudflare 의 WAF (방화벽) 에 일단 검문을 거친다.

- 1단계로는 IP 평판을 검사한다.
  - 의심대상이면
    - JavaScript 챌린지를 시도.

      > JavaScript 챌린지?
      >
      >
      > ```mermaid
            > sequenceDiagram
            >     participant C as 크롤러<br/>(Python/requests)
            >     participant CF as Cloudflare<br/>챌린지 페이지
            >     participant W as 실제 웹사이트
            >     
            >     C->>CF: 1. "HTML 주세요"
            >     CF->>C: 2. JavaScript 코드 전송
            >     
            >     rect rgb(255, 107, 107)
            >     Note over C: JavaScript를 실행할 수 없음!
            >     C->>C: 3. ❌ 그냥 HTML만 받음
            >     end
            >     
            >     C->>CF: 4. 정답 없이 접근 시도
            >     CF->>C: 5. ❌ 403 Forbidden
            >     
            >     Note over C,W: 실제 웹사이트에<br/>도달 못함!
            > ```
      >
      > - 클라이언트가 보내는 요청
          >
          >     ```
            >     GET /protected-page HTTP/1.1
            >     Host: cloudflare-site.com
            >     User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0
            >     Accept: text/html,application/xhtml+xml,application/xml
            >     Accept-Language: ko-KR,ko;q=0.9
            >     Connection: keep-alive
            >     ```
          >
          >     **해석**:
          >     ```
            >     "안녕! 나는 Chrome 브라우저야.
            >     cloudflare-site.com의 /protected-page를 보여줘!"
            >     ```
      >
      > - Cloud Flare 가 보내는 응답
          >
          >     ```
            >     HTTP/1.1 200 OK
            >     Content-Type: text/html; charset=utf-8
            >     Server: cloudflare
            >     CF-RAY: 1234567890abc-ICN
            >     Content-Length: 5432
            >     
            >     <!DOCTYPE html>
            >     <html>
            >     <head>
            >         <title>Just a moment...</title>
            >     </head>
            >     <body>
            >         <h1>Checking your browser...</h1>
            >         
            >         <!-- ⭐ 여기부터 JavaScript 코드! -->
            >         <script>
            >             // Cloudflare 챌린지 코드
            >             (function() {
            >                 var a = 12345;
            >                 var b = 67890;
            >                 var answer = a + b;
            >                 
            >                 // 정답을 쿠키에 저장
            >                 document.cookie = "cf_clearance=" + answer;
            >                 
            >                 // 5초 후 페이지 새로고침
            >                 setTimeout(function() {
            >                     window.location.reload();
            >                 }, 5000);
            >             })();
            >         </script>
            >     </body>
            >     </html>
            >     ```
      >
      > - 자바스크립트 계산 내용을 가지고 페이지 접근해서 검사 통과해야 접근이 가능함.
      > - 브라우저의 경우 값을 받아서 계산을 하지만, 크롤러는 값을 그냥 받기만해서 계산을 하지 못함. 크롤러인지 브라우저인지 거르는 역할임
- 2단계로는 TLS 핑거프린트 분석을 한다.

  > TLS 핑거프린트 분석?
  >
  > - 쉽게 설명한다면, Chrome 브라우저는 노크를 3번하고, 파이썬 크롤러는 2번하는 방문시 특징이 있다고 생각면 된다.
  > - 파이썬 크롤러가 User-Agent 만 변경하는 경우
      >
      >     ```
    >     # 크롤러가 User-Agent만 바꾸는 상황
    >     headers = {'User-Agent': 'Chrome/120.0.0.0'}  # "저는 Chrome입니다!" 라고 말함 
    >     ```
  >
  > - 서버 입장에서는
      >     - 말은 크롬이라고 하는데
  >     - 악수하는 방식은 파이썬인거임
  >     - 문 두드리는 패턴을 보고 파이썬 크롤러임을 알고 차단한다.
  > - 핑거프린트를 만드는 주요 요소에는
      >     1. Cipher Suites ( 암호화 스위트 )
               >         - 클라이언트가 지원하는 암호화 알고리즘 목록과 순서
                           >
                           >             ```
    >             Chrome 120:
    >             TLS_AES_128_GCM_SHA256 (0x1301)
    >             TLS_AES_256_GCM_SHA384 (0x1302)
    >             TLS_CHACHA20_POLY1305_SHA256 (0x1303)
    >             TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xC02B)
    >             ...
    >             
    >             Firefox 121:
    >             TLS_AES_128_GCM_SHA256 (0x1301)
    >             TLS_CHACHA20_POLY1305_SHA256 (0x1303)  // 순서 다름!
    >             TLS_AES_256_GCM_SHA384 (0x1302)
    >             ...
    >             ```
  >
  >     2. Extensions ( 확장 기능 목록 등)
  >
  > 이 있는데
  >
  > 실제로 가장 많이 쓰이는 방식은 JA3 핑거프린트 방식이다.
  >
  > JA3 는
  >
  > ```
    > JA3 = MD5(
    >     SSLVersion, // ssl 버전
    >     Ciphers,  // 암호화 스위트
    >     Extensions, // 확장 기능 목록
    >     EllipticCurves,
    >     EllipticCurvePointFormats
    > )
    > ```
  >
  > - 으로서,  Chorme 에서예시로 JA3 문자열로는
  >
  > ```
    > 771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,0-23-65281-10-11-35-16-5-13-18-51-45-43-27-17513,29-23-24,0
    > ```
  >
  > - 위와 같고, MD5 해시 후에는
      >
      >     ```
    >     JA3: cd08e31fd8d8e2f737e1f0e8e6e7e1e1
    >     ```
  >
  > - 이런식으로 구성되어 있다.
  > - 실제 탐지하는 방법
      >     - 정상 브라우저 Chorme 120
              >
              >         ```
    >         TLS Version: 0x0303 (TLS 1.2) but advertises 0x0304 (TLS 1.3) in extensions
    >         Cipher Suites: 15개
    >         Extensions: 16개 (특정 순서)
    >         JA3: cd08e31fd8d8e2f737e1f0e8e6e7e1e1
    >         ```
  >
  >     - 파이썬 크롤러 요청
          >
          >         ```
    >         TLS Version: 0x0303 (TLS 1.2)
    >         Cipher Suites: 9개만
    >         Extensions: 5개만
    >         JA3: 51c64c77e60f3980eea90869b68c58a8  // 완전히 다른 해시!
    >         ```
  >
  > - 필드가 일단 너무 많고, 순서도 다르면 안되며, 저수준의 라이브러리에서 결정되는 내용이 많기에, 구현에 따라 결정이 된다
  > - 상당히 충족하기 힘든 조건이라고 볼 수 있음.
  > - 브라우저가 업데이트가 되면 핑거프린트도 변경됨.
  - 봇 패턴을 감지한다면
    - 브라우저를 검증한다.
- 3단계로는 HTTP 헤더를 분석한다.

  > HTTP 헤더 분석?
  >
  > - 헤더에 Referer 가 있는지,, Accept-Language 등이 있는지 각각 원래 크롬이나 사파리라면 있어야하는 헤더의 값이나 순서가 안맞는다 던가의 헤더 구조 분석을 하는거임
  - 이상 행동 발생시 CAPTCHA 를 태운다.
    - 실제 브라우저에서 사용자가 퍼즐을 조립하는 등의 행위를 직접 수행을 어느 시간내에 해야 봇이 아님을 증명할 수 있는 것이다.
- 이렇게 모든 검증을 거치는 경우
  - `cf_clearance 쿠키` 를 발급하게 된다

## 차단 우회 방법

1. IP 로테이션
  - 단순 IP 를 여러개 사용하는 방식
  - 하나가 차단되면 다른 IP 로 요청하고.. 이런식
  - 너무 단순하긴한데 결국에 IP 차단도 비정상적인 요청이라고 막힐 가능성이 높다
  - 다만, 구현이 단순해서 간단하게 사용하기에 자동 용이하다.
2. User-Agent 로테이션
  - 이것도 동일
3. FlareSolverr 사용
  - 클라우드 플레어 DDos-GUard 같은 자바스크립트 챌린지를 자동으로 해결해주는 `프록시 서버` 임

    ```mermaid
    sequenceDiagram
        participant C as 크롤러
        participant FS as FlareSolverr
        participant B as 실제 브라우저<br/>(Selenium)
        participant CF as Cloudflare
        participant T as 타겟 사이트
        
        C->>FS: POST /v1<br/>{"cmd": "request.get",<br/>"url": "https://example.com"}
        
        FS->>B: 브라우저 시작
        B->>CF: 페이지 접속
        
        Note over CF,T: JavaScript Challenge 발동!
        
        CF->>B: JS 코드 실행 요청
        B->>B: JS 실행 (5-10초)
        B->>CF: Challenge 해결
        
        CF->>T: 쿠키 발급 및 리다이렉트
        T->>B: 실제 콘텐츠 반환
        
        B->>FS: HTML + 쿠키 전달
        FS->>C: 응답 반환<br/>{<br/>"solution": {<br/>  "cookies": [...],<br/>  "userAgent": "...",<br/>  "response": "HTML..."<br/>}<br/>}
        
        Note over C: 쿠키를 저장하고<br/>다음 요청에 재사용!
    ```

  - 클라우드 플레어에 FlareSolverr 에 요청을 통해 해결된 쿠키랑 HTML 을 전달받을 수 있음
  - 한번의 챌린지 해결로 일반 request 에 쿠키를 끼워서 재사용이 가능해진다.
  - 처음 solving 과정에서 리소스소 많이 쓰고 동시 처리 제한에 한계가 있어서.. 대안이 될 까 싶다.
4. ScrapingBee
  - 웹 스크래핑을 위한 유로 클라우드 API
    - 복잡한 차단 우회를 직접 구현 X
  - 실제 사이트 구축시에는 사용하는게 의미가 없음..
  - 요즘 사이트 같은 경우 HTML 깡통에 js 가 나중에 데이터를 채우는 경우가 많은데
    - 쿠팡같은 경우 특정 카테고리의 상품을 1,000 개 크롤링시에
      - 약 65원 정도로 책정한다고함..
      - 비용이 엄청나긴하지만
    - 실제 서버위에서 구동되는 경우 서버비, 개발시간을 고려하면.. 합리적인가.. 모르겠다.
