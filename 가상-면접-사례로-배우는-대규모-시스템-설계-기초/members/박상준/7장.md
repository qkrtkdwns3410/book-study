## SnowFlake 는 현재 deprecated 됨.

- 트위터는 현재 완전히 재개발된 snowflake 사용중
    - 오픈소스로 내기에는 내부적인 시스템에 연관도가 높아 오픈소스로 출시 불가능
- https://github.com/twitter-archive/snowflake

## 스노 플레이크 ID 구조  (64비트)

| **필드** | **비트 수** | **설명** |
| --- | --- | --- |
| **사인(Sign) 비트** | 1비트 | 현재는 사용하지 않지만, 양수/음수 구분을 위해 남겨둠 (보통 0) |
| **타임스탬프** | 41비트 | 기원 시각(Epoch) 이후 경과된 밀리초(ms) 값 |
| **데이터센터 ID** | 5비트 | 2^5 = 32개의 데이터센터를 식별 가능 |
| **서버 ID** | 5비트 | 데이터센터당 2^5 = 32개의 서버를 식별 가능 |
| **일련번호** | 12비트 | 동일 밀리초 내에서 생성된 ID 순서 (1씩 증가, ms마다 0으로 초기화) |

## 12비트 일련번호가 1밀리초 안에 4096개를 넘는다면?

- 트위터 Snow Flake 에서는 12비트 시퀀스가 1ms 안에 4095개를 다 채운다면

    ```text
    if (lastTimestamp == timestamp) { // 같은 타임스탬프 ( 같은 ms ) 면
      sequence = (sequence + 1) & sequenceMask // 시퀀스 증대
      if (sequence == 0) {
        timestamp = tilNextMillis(lastTimestamp)
      }
    } else {
      sequence = 0
    }
    ---
    private[this] val sequenceBits = 12L
    
    // private[this] val sequence Mask -> -1L ^ ( -1L << sequenceBits )
    -1L -> (64비트) = ... 11111111111111 (비트가 전부 1)
    -1L << 12 => 왼쪽으로 12비트 시프트 -> 오른쪽 12비트가 전부 0으로 기록
    
    -1L ^ (-1L << 12) -> XOR 처리 -> 오른쪽 12비트만 1
    
    즉, sequenceMask -> 0b1111_1111_1111 = 4095 ( 12개 비트가 전부1 )
    
    - 시퀀스 4095 에서  + 1  ( sequence = 4095 + 1 ) & 4095 -> 4096 & 4095
    
    처리시  
    
    4096- >   1 0 0 0 0 0 0 0 0 0 0 0 0
    				  ↑ 13번째 비트만 1, 나머지 0
    4095 ->    0 1 1 1 1 1 1 1 1 1 1 1 1
    						  ↑ 12개 1
    						  (13번째 비트는 0)
    AND  ->    0 0 0 0 0 0 0 0 0 0 0 0 0
    
    sequence 가 0이 된다.
    timestamp 에서 tiNextMillis 호출
    
    ---
    protected def tilNextMillis(lastTimestamp: Long): Long = {
      var timestamp = timeGen()
      while (timestamp <= lastTimestamp) {
        timestamp = timeGen()
      }
    }
    
    -> 현재 시간 ms 직전에 발급한 lastTimeStamp 보다 같거나 작은 시간 동안 timeGen() 호출
    다음 밀리초까지 busy-wait 처리 => 시간이 바뀔때까지 반복해서 체크
    ```

- 기다려봤자 1ms 정도임 엄청 미미한 정도

## NTP 가 뭘까?

- 네트워크로 연결된 컴퓨터들끼리 `시간을 동기화` 하기 위해 만들어진 프로토콜

### MSA 환경에서

- 하나의 요청이 여러 서비스를 통해 거쳐 처리되는데, `분산 트레이싱` 을 활용해 로그를 추적함 ELK 같은 스택에서 수많은 서버에서 던져니는 로그를 수집해 `시간순` 으로 보여주는데,
- 서버간 시계가 맞지 않으면 로그 순서가 `결제` 가 먼저 찍히고, `주문` 이 뒤에 찍히는 문제가 발생하기도함.
- 현대에서 디버깅하는데, 로그가 지 혼자서  39분에 30초에 `결제` 39분 30초 100ms 에 `주문` 이 찍혀있으면 로그 자체를 신뢰할 수 없는 문제도 생김.

### 스노플레이크 ID 생성기 라이브러리에서는 어떻게 처리할까?

- 시계가 뒤로 간다면 에러는 던진다고 함.

    ```java
    if (timestamp < lastTimestamp) {
      exceptionCounter.incr(1)
      log.error("clock is moving backwards.  Rejecting requests until %d.", lastTimestamp);
      throw new InvalidSystemClock("Clock moved backwards.  Refusing to generate id for %d milliseconds".format(
        lastTimestamp - timestamp))
    }
    ```

- 뒤로 가지 않게하려면
    - NTP 옵션에 ntpd -x 옵션을 준다면
        - slew ( 미세 조정 ) 을 한다고한다.
        - 만약 실제 시간이 9시 59분 이고, 잘못된 시간이 10시 00 분이라면
        - 10시 00분의 시간을 천천히 흐르게한다.
        - 이러면 실제 시간이 잘못된 서버 시간과 동일해 지더라도, ID 중복이 발생하지 않을 것이다.
        - 다만, 어느정도의 시간상 오차발생은 감안해야한다.
