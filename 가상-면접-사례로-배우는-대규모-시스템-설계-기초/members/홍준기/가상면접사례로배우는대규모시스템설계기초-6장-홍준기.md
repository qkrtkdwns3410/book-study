# 6장

# 이해를 되짚어 보자.
6장 내용이 논리적으로 어려워 예시를 통해 이해를 완벽히 해보자!!

## 가십 프로토콜 :: 수많은 노드들의 장애 확인 방법

분산 서버 환경에서 각 서버(노드)는 모든 서버에 대한 카운터 정보를 관리하면서 주기적으로 랜덤한 몇 개의 서버에 이 정보를 그대로 보냄

가정 : 분산 물리 노드가 5000개

### 비효율적인 방식

중앙 서버가 10초마다 5000개의 서버에 대해 ping-pong 수행

10초에 5000번의 핑퐁 통신

### 효율적인 방식(책)

10초에 특정 한 서버가 5개의 서버에 자신이 가진 서버 카운터 프로필을 전송
5개 서버는 5000개의 서버에 대해 카운터가 올라갔는지 확인(올라갔으면 그 서버들은 정상) 안올라가 있으면 서버 장애 후보

10초에 5번의 핑퐁 통신

## 일시적 vs 영구적 장애

### 일시적일 때

장애 노드에 처리되어야 할 데이터 다른 노드가 대신 처리, 대신 다른 노드가 대신 처리하면서 힌트를 기록하여, 정상화되면 힌트 기반 처리한 데이터 이관

### 영구적일 때

(복구 되었을 때) 머클 트리 방식으로 데이터를 버킷화 하여 문제있는 버킷만 정상 버킷으로부터 복붙.

### 일시적, 영구적 장애의 구분

보통은 일시적 장애 -> 영구적 장애로의 발전의 흐름을 딴다.

일시적일 때, 다른 노드가 열심히 처리 + 힌트기록 하다가 임계점이 넘으면 일시적 장애 노드는 영구적 장애 노드가 되고 그냥 하나 없는 상태로 처리가 진행된다.

그러다가 영구적 장애 노드가 복귀하면 머클 트리 방식으로 복구하게 된다.

# 6장에 대한 이해

6장은 디스크 기반 키-값 저장소에 대한 이야기이다. 레디스를 생각하면 내용이 달라질 부분이 많다.

* ex. 메모리에 없을 때, 블룸필터 -> SSTable -> 값 반환
  * 레디스는 pure 인 메모리다.(복구를 위해서만 디스크에 저장.)
  
# 정족수 합의

## 강한 일관성에 대한 의문

* W + R > N 이면 왜 강한 일관성이지?
  * ex. W = 2, R = 2, N = 3일 경우
  * W=3, R=3이어야 완전한 일관성 확보 아닌가?

### 쓰기 상황
노드 A: 버전 2 (최신)
노드 B: 버전 2 (최신)
노드 C: 버전 1 (업데이트 안 됨/구식)

### 읽기 상황
* 읽기는 노드 3개중 무작위로 2개를 읽고 최신인 걸 고르면 "무조건" 최신을 읽음.

(A,B) (B,C) (A,C) = (최신,최신) (최신, 구식) (최신, 구식)

N = 50이고 W=49, R=2여도 보장되고, N=5000이고 W=1, R=5000이어도 보장됨.



