# URL 단축기가 필요한 이유

## 1. 실제 문제 상황

### 1.1 문자 메시지(SMS) 제약

실제로 마케팅 팀에서 프로모션 SMS를 발송한다고 가정해보자.

```
[이벤트] 봄맞이 30% 할인!
https://example-shop.com/promotion/2024/spring-sale?utm_source=sms&utm_medium=marketing&utm_campaign=spring2024&user_id=12345&ref=mobile&lang=ko
```

SMS는 한 건당 90바이트(한글 45자)를 초과하면 장문 메시지로 요금이 2배가 된다. 위 URL만 150자가 넘어간다. 100만 건을 발송한다면 단순히 URL 때문에 SMS 비용이 2배로 증가한다.

URL 단축 후:
```
[이벤트] 봄맞이 30% 할인!
https://short.url/a8k2m
```

이렇게 되면 한글로 더 많은 메시지를 담을 수 있고 비용도 절감된다.

### 1.2 소셜 미디어 글자 수 제한

트위터(X)는 여전히 글자 수 제한이 있다.

```
신제품 출시! 지금 확인하세요
https://our-company-website.com/products/new-arrivals/2024/category/electronics/smartphones/model-xyz-pro-max?color=black&storage=256gb&promo=launch
```

이런 URL은 트윗 내용을 거의 다 잡아먹는다. 실제로 말하고 싶은 내용을 쓸 공간이 없어진다.

### 1.3 인쇄 매체와 QR 코드

명함이나 포스터에 URL을 인쇄할 때를 생각해보자.

```
방문하세요: https://www.my-personal-portfolio-website-2024.com/projects/showcase/web-development/recent-works
```

이걸 명함에 인쇄하면 글자가 너무 작아서 읽을 수가 없다. QR 코드로 만들어도 URL이 길면 QR 코드가 복잡해져서 스캔 성공률이 떨어진다.

### 1.4 사용자 경험 문제

고객 상담 중 전화로 URL을 알려줘야 하는 상황:

```
"네, 주소는 h t t p s 콜론 슬래시 슬래시 w w w 점 o u r dash s e r v i c e 점 c o m 슬래시 s u p p o r t 슬래시 f a q 물음표 c a t e g o r y 등호 a c c o u n t..."
```

실제로는 고객이 중간에 포기하거나 오타가 발생한다. 단축 URL이면 "short.ly/help123" 정도로 간단히 전달 가능하다.

### 1.5 분석과 추적의 어려움

같은 페이지를 여러 채널에서 공유할 때:

```
- 이메일: https://shop.com/product/item123
- 페이스북: https://shop.com/product/item123
- 인스타그램: https://shop.com/product/item123
```

이렇게 하면 어느 채널에서 트래픽이 왔는지 구분이 안 된다. UTM 파라미터를 붙이면 URL이 너무 길어지고, 사용자가 URL을 보고 복잡하다고 느껴 클릭을 꺼린다.

## 2. URL 단축을 하지 않았을 때의 실제 문제

### 2.1 보안 위험 노출

```
https://payment-gateway.com/checkout?session_id=a8f2d9e1b4c7&user_token=xyz123&merchant_id=5678
```

이런 URL을 그대로 공유하면 세션 정보가 노출된다. URL을 복사해서 다른 사람에게 전달하는 순간 보안 문제가 발생할 수 있다.

### 2.2 링크 변경의 어려움

마케팅 캠페인을 이미 시작한 후:

```
포스터 1000장 인쇄: https://event.com/summer-sale-2024
```

그런데 이벤트 페이지 구조를 변경해야 한다면? 모든 포스터를 다시 인쇄해야 한다. 단축 URL을 사용했다면 리디렉션 대상만 변경하면 된다.

### 2.3 브랜딩 기회 상실

```
https://bit.ly/company-event
vs
https://go.ourcompany.com/event
```

커스텀 도메인을 사용한 단축 URL은 브랜드 신뢰도를 높인다. 사용자는 두 번째 링크가 공식 링크라는 것을 직관적으로 인식한다.

### 4.2 301 vs 302 리디렉션

**302 리디렉션 (임시)**
```java
@GetMapping("/{shortCode}")
public ResponseEntity<Void> redirect(@PathVariable String shortCode) {
    String longUrl = urlService.expand(shortCode);
    return ResponseEntity
        .status(HttpStatus.FOUND) // 302
        .header("Location", longUrl)
        .build();
}
```

구글은 302를 보고 "이 링크는 곧 바뀔 수 있다"고 판단한다. 검색 결과에는 단축 URL이 계속 노출된다.

검색 결과 예시:
```
https://short.url/xyz
"블로그 제목..."
```

사용자는 `short.url` 도메인만 보고 신뢰도가 떨어진다고 판단해 클릭하지 않을 수 있다.

**301 리디렉션 (영구)**
```java
@GetMapping("/{shortCode}")
public ResponseEntity<Void> redirect(@PathVariable String shortCode) {
    String longUrl = urlService.expand(shortCode);
    return ResponseEntity
        .status(HttpStatus.MOVED_PERMANENTLY) // 301
        .header("Location", longUrl)
        .build();
}
```

301을 사용하면 구글은 "영구 이동"으로 판단하고, 시간이 지나면 검색 결과에 원본 URL을 표시한다. 하지만 크롤링 예산은 계속 소모된다.

### 4.3 크롤러별 리디렉션 전략

실무에서는 사용자와 크롤러를 구분해서 처리한다.

```java
@GetMapping("/{shortCode}")
public ResponseEntity<Void> redirect(@PathVariable String shortCode,
                                     @RequestHeader("User-Agent") String userAgent) {
    String longUrl = urlService.expand(shortCode);

    if (isCrawlerBot(userAgent)) {
        // 봇에게는 301 + canonical 헤더
        return ResponseEntity
            .status(HttpStatus.MOVED_PERMANENTLY)
            .header("Location", longUrl)
            .header("Link", "<" + longUrl + ">; rel=\"canonical\"")
            .build();
    }

    // 일반 사용자에게는 302 (클릭 추적 가능)
    return ResponseEntity
        .status(HttpStatus.FOUND)
        .header("Location", longUrl)
        .build();
}

private boolean isCrawlerBot(String userAgent) {
    return userAgent != null && (
        userAgent.contains("Googlebot") ||
        userAgent.contains("Bingbot") ||
        userAgent.contains("Yeti") || // 네이버
        userAgent.contains("facebookexternalhit")
    );
}
```

### 4.4 소셜 미디어 크롤러 문제

페이스북이나 트위터는 단축 URL을 따라가서 메타데이터를 수집한다.

```
사용자 공유: https://short.url/article
  ↓
페이스북 크롤러가 리디렉션 따라감
  ↓
원본: https://blog.com/article (메타 태그 확인)
```

원본 페이지에 Open Graph 태그가 없으면 썸네일이 표시되지 않는다.

**해결책: 크롤러에게 메타 정보 제공**

```java
@GetMapping("/{shortCode}")
public Object redirect(@PathVariable String shortCode,
                      @RequestHeader("User-Agent") String userAgent) {
    String longUrl = urlService.expand(shortCode);

    if (isSocialCrawler(userAgent)) {
        UrlMetadata metadata = urlService.getMetadata(shortCode);
        return ResponseEntity.ok()
            .contentType(MediaType.TEXT_HTML)
            .body(generateMetaPage(longUrl, metadata));
    }

    return ResponseEntity
        .status(HttpStatus.FOUND)
        .header("Location", longUrl)
        .build();
}

private String generateMetaPage(String longUrl, UrlMetadata metadata) {
    return """
        <!DOCTYPE html>
        <html>
        <head>
            <meta property="og:title" content="%s">
            <meta property="og:description" content="%s">
            <meta property="og:image" content="%s">
            <meta http-equiv="refresh" content="0;url=%s">
        </head>
        <body>Redirecting...</body>
        </html>
        """.formatted(
            metadata.getTitle(),
            metadata.getDescription(),
            metadata.getImageUrl(),
            longUrl
        );
}
```

### 4.5 중복 컨텐츠 문제

같은 페이지를 여러 단축 URL로 만들면:

```
https://short.url/abc → https://blog.com/article
https://short.url/xyz → https://blog.com/article
https://short.url/def → https://blog.com/article
```

구글이 이를 중복 컨텐츠로 판단할 수 있다. 특히 302를 사용하면 세 개 URL 모두 인덱싱 대상이 된다.

**해결책: 캐노니컬 단축 URL 관리**

```java
@Entity
public class UrlEntity {
    private String shortCode;
    private String longUrl;
    private boolean isCanonical;
    private String canonicalShortCode;
}

@Service
public class UrlService {

    public String shorten(String longUrl) {
        // 이미 존재하는 캐노니컬 URL 찾기
        UrlEntity canonical = urlRepository
            .findByLongUrlAndIsCanonical(longUrl, true);

        if (canonical != null) {
            // 새 단축 URL 생성하되, 캐노니컬 참조 저장
            String newCode = generateShortCode();
            UrlEntity newUrl = new UrlEntity(newCode, longUrl);
            newUrl.setCanonicalShortCode(canonical.getShortCode());
            urlRepository.save(newUrl);
            return newCode;
        }

        // 첫 번째는 캐노니컬로 설정
        String code = generateShortCode();
        UrlEntity url = new UrlEntity(code, longUrl);
        url.setCanonical(true);
        urlRepository.save(url);
        return code;
    }
}
```

### 4.6 robots.txt 설정

단축 URL 서비스 자체는 검색 결과에 노출될 필요가 없다.

```java
@RestController
public class RobotsTxtController {

    @GetMapping(value = "/robots.txt", produces = "text/plain")
    public String robots() {
        return """
            User-agent: *
            Disallow: /

            # 리디렉션은 정상 작동
            # 실제 컨텐츠는 원본 URL에 있음
            """;
    }
}
```

이렇게 하면 구글이 단축 URL 자체는 인덱싱하지 않지만, 리디렉션은 정상적으로 따라간다.

### 4.7 실무 가이드라인

**단축 URL을 써야 하는 경우:**
- SMS, 트위터 등 글자 수 제한
- 일시적 프로모션 캠페인
- A/B 테스트용 추적 링크
- QR 코드, 인쇄 매체

**원본 URL을 써야 하는 경우:**
- 주요 상품 페이지
- 블로그 아티클
- 검색 유입을 기대하는 모든 페이지

```java
@Service
public class SmartUrlService {

    public String createShareUrl(String originalUrl, ContentType type) {
        // 검색 유입이 중요한 컨텐츠는 원본 유지
        if (type == ContentType.SEO_CRITICAL) {
            return originalUrl;
        }

        // 캠페인, 소셜 공유는 단축
        return shortenUrl(originalUrl);
    }
}
```

실무에서는 모든 URL을 단축하지 않는다. 검색엔진 최적화가 필요한 페이지는 원본 URL을 유지하고, 추적이나 공유 편의성이 중요한 경우에만 단축 URL을 사용한다.