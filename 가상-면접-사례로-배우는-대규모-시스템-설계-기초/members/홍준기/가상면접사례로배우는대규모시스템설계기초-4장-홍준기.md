# 4장

## 국내 서비스 회사 사례

### 배달의민족 - API Gateway

출처 : https://inspirit941.tistory.com/567

* 기본적으로 Spring Cloud Gateway 사용
* 유연한 설정 / 동적인 기능을 위해 커스텀해서 사용
  * property기반의 방식 -> db기반의 방식 (여기서 설정을 동적으로 바꾸는 듯.)
* 게이트웨이 이외에 다른 로드밸런서 같은 것이 존재하지는 않고 라우팅 처리도 이 gateway에서 수행.
* 앱 -> api 게이트웨이 (다중화) -> 프론트엔드 (다중화) -> 웹 서버 (다중화)

### G마켓 - AOP

* 다중 컨슈머 환경에서 Redis를 이용해 '고정 윈도우 카운터' 방식의 Rate Limiter를 구현할 때 발생하는 경합 조건(Race Condition) 문제를 해결하는 과정을 보여줌.
*  초기 설계에서는 Java 애플리케이션 레벨에서 '조회 후 증가' 로직을 분리해 처리했으나, 16개의 컨슈머가 동시에 접근하며 1분당 100건 제한을 초과하는 오류가 발생. 
*  이를 해결하기 위해 Redis Cluster에서 지원하지 않는 트랜잭션 대신, Lua Script를 도입하여 '조회-비교-증가' 과정을 단일 원자적(Atomic) 연산으로 묶어 동시성 문제를 완벽히 해결하고 시스템의 신뢰성을 확보한 것이 핵심.
*  즉 Redis는 싱글 스레드라 데이터 값 처리 자체에 대한 동시성 걱정은 없지만 레디스 값 체크 -> 행동의 과정적으로 발생하는 "사이클의 원자성 문제"를 Lua Script로 하여금 해결한 것.

## 레디스 - Rate Limit 구현

출처 : https://redis.io/tutorials/howtos/ratelimiting/

## 처리율 제한 장치의 고려 지점

* 어디서 필요한 건가? -> 처리율 제한 장치의 위치 결정 가능
* 분산환경인가? -> 동기화, race condition 등 고려해야할 점이 많아짐
* 어떤 규칙을 적용해야하는가? -> 이것도 위치와 관련됨.

## 정리

책에서 언급하는 필요한 알고리즘을 외우기보단, 적용 방식에 대한 고민 지점을 파악하는 것이 중요할 것 같다.

이 횡단 관심사를 어느 지점에 적용시킬 것인지, 분산 환경에서 고려되어야할 것들이나, 엄격하게 rate limit 정책을 지켜야하는지 등등 이에 따라 알고리즘은 달라지고, 라이브러리, 적용 위치가 달라진다.