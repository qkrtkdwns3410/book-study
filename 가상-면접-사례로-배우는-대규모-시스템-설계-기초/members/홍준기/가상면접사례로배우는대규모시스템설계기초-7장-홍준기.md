# 7장

## Snowflake with JPA

```java
@Entity
public class User {
    @Id
    @Tsid
    private Long id;
}
```
* 이렇게 쓸 수 있다고 함

## 64비트 비트에 정보가 담기는 것은 알겠는데 JPA에서 이를 Long으로 어떻게 받아내는거지?

### 저장될 ID 가정
* 서비스 오픈일 : 2025/01/01 00:00
* ID가 저장되는 시점의 time : 2026/02/01 00:00
* 오픈 일부터 ID 저장되는 시점의 시간 차 : 2,678,400,000 (시간 값)
* 저장될 DB 서버 번호 = 7
* 일련번호 = 0

#### 시간 값을 22칸 왼쪽으로 밀기

시간 값(10진수)에 대해 2진수 기준 22칸을 왼쪽으로 민다는 것은

시간 값에 2^22를 곱하는 것과 같다.

22칸을 미는 이유는 스노플레이크에 제시된 시간 뒤의 정보들을 담기 위해서다.

2,678,400,000 x 2^22 = 약 1경 1234조

서버 번호 = 7은 일련번호를 위해 12칸을 밀어야한다.

7 * 2^12 = 28672

일련번호는 0이므로

최종 10진수 ID값은 (2,678,400,000 x 2^22) + (7 * 2^12)가 된다.

어쨌든 2진수 기준 

#### 의문

* 시간 부분이 완전히 동일한 ID가 서로 다른 서버에 갈 때는 정렬에 대한 의존이 서버 번호에 생겨버리는데?
  * 이럴 확률이 거의 없는 것은 둘째 치고 그정도 정렬이 뒤집히는 것은 딱히 문제가 안된다. 사실상 같은 시각인데 그 두 개가 정렬이 뒤집히는 것은 딱히 문제 안됨.

* 시간 부분은 A가 B보다 더 빠른데, 서버 번호때문에 순서가 역전될 수 있지 않나?
  * 절대로 불가능 -> 수학적으로 시간이 한 단위라도 더 크면 서버 번호가 아무리 커도 절대 이길 수 없음. 애초에 시간의 가장 작은 단위가 서버 번호의 가장 큰 자릿수보다 크기 때문 (억만 장자는 절때 조만 장자를 이길 수 없다.)

## 스노플레이크의 69년

맨 앞의 값은 부호 비트이기에 0이다. 이 부호비트 다음 비트가 1이 되면서 그 뒤 비트들이 모두 1이 되는 순간 다음 시간 단위에서는 42번째 칸으로 넘어가게 되며 부호 비트를 침범하게 되고 ID시스템은 깨져버린다.

그에 대한 시간 EPOCH이 69.8년이다.

서비스 시작일과 현재 시간 차이로 ID를 세팅하는 것이기에 서비스 시작일을 바보같이 유닉스 기본 시간(1970/01/01)같은 것으로 하면 안된다.

오늘을 서비스 오픈일로 한다면 2095년까지는 이 ID시스템은 멀쩡하게 살아있을 것이다.

## 스노플레이크와 auto increment의 분산 시스템에서 차이

Auto increment는 현재 내가 뽑는 ID가 이전의 ID 값을 의존함.
* 같은 시스템에서 존재한다면 이는 큰 문제가 안되지만 다른 시스템일 경우 문제가 생김. "나의 Before를 찾을 수 없거나 애매해지는 문제"

스노플레이크는 그냥 현재 시간을 찍기에 독립적이다. 순수하게 시간만 찍으면 아주 적은 확률이지만 충돌이 발생 가능, 그래서 그 뒤 22비트를 활용.

## 22비트에 대한 자유도

* 트위터가 처음에 10비트(머신) + 12비트(시퀀스)로 정한 건 트위터의 상황에 맞춘 것일 뿐이다.

* 시간 뒤에 배치되는 400만의 공간(22비트)은 서비스 특성에 맞춰 맘대로 튜닝 가능

* 합쳐서 63비트만 되면 됨... 41비트(시간 epoch) + 22비트(your choice)






