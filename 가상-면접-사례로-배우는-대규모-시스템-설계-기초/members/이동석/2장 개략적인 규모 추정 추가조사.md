- 2의 제곱수, 응답지연 값, 가용성에 관계된 수치들을 이해해야한다.
- https://bytebytego.com/guides/which-latency-numbers-should-you-know/
  ![latency number you should know](https://assets.bytebytego.com/diagrams/0250-latency-numbers.jpg)

연습해두면 좋을것 : QPS, 최대 qps, 저장소 요구량, 캐시 요구량, 서버 수

- 아래의 캐시 용량 추정, 서버수 용량 추정, 디비 서버수 용량 추정을 제미나이에게 질의해봤어요.

# 캐시 용량 추정 방법론

소프트웨어 설계 단계에서 캐시 요구량(Cache Capacity Estimation)을 추정하는 것은 시스템의 성능과 비용을 결정짓는 매우 중요한 과정입니다. 단순히 "메모리가 많으면 좋겠지"라는 접근보다는, 데이터의 특성과 트래픽 패턴을 분석하는 정교한 계산이 필요합니다.

일반적으로 다음과 같은 **4단계 프로세스**를 통해 추정할 수 있습니다.

---

## 1. 데이터 대상 및 생명주기 정의

먼저 무엇을, 얼마나 오래 저장할지 결정해야 합니다.

- **저장 대상:** 세션 정보, API 응답 결과, DB 쿼리 결과 등
- **만료 정책 (TTL):** 데이터가 캐시에 머무는 시간 (예: 1시간, 1일)
- **제거 알고리즘:** 캐시가 가득 찼을 때 어떤 데이터를 지울 것인가? (보통 **LRU**: Least Recently Used 방식 사용)

## 2. 개별 데이터 크기 계산 (Object Size)

캐시에 들어갈 데이터 한 건의 평균 크기를 계산합니다.

- **예시:** 사용자 프로필 정보를 캐싱한다고 가정
  - User ID (Long): 8 bytes
  - User Name (String, 20자): 약 40 bytes
  - Email (String, 30자): 약 60 bytes
  - **합계:** 약 100 bytes (메타데이터 및 직렬화 오버헤드를 포함해 넉넉히 **200 bytes**로 잡는 것이 안전함)

## 3. 총 용량 추정 산식

가장 핵심이 되는 계산식입니다. 보통 **'일일 활동 사용자(DAU)'**나 **'초당 요청 수(RPS)'**를 기준으로 계산합니다.

$$Total\ Cache\ Size = (Number\ of\ Objects) \times (Average\ Object\ Size) \times (Overhead\ Factor)$$

### 상세 계산 예시

> 가정:
>
> - 전체 사용자: 1,000만 명
> - 일일 활동 사용자 (DAU): 100만 명
> - 캐싱 대상: 상위 20%의 인기 게시물 (파레토 법칙 적용)
> - 게시물당 크기: 500 bytes

1. **대상 데이터 수:** 100만 명 $\times$ 20% = 200,000개
2. **순수 데이터 용량:** 200,000 $\times$ 500 bytes = 100,000,000 bytes (약 100MB)
3. **버퍼 및 복제본 고려:** Redis 등의 클러스터 구성 및 인덱스 오버헤드(보통 2배) 적용 시 **약 200MB~300MB** 필요

---

## 4. 파레토 법칙(80/20 법칙)의 적용

모든 데이터를 캐싱하는 것은 불가능하며 비효율적입니다. 일반적으로 **전체 요청의 80%를 처리하는 20%의 "Hot Data"**를 캐싱하는 것을 목표로 합니다.

| **구분**      | **전략**         | **비고**            |
| ------------- | ---------------- | ------------------- |
| **Hot Data**  | 캐시에 상주      | 읽기 성능 극대화    |
| **Warm Data** | 빈도에 따라 캐싱 | TTL을 짧게 설정     |
| **Cold Data** | DB에서 직접 읽기 | 캐시 효율 저하 방지 |

---

## 5. 인프라 관점의 고려사항 (Over-provisioning)

추정된 값에 최소 **25% ~ 50%의 여유 공간**을 추가해야 합니다.

- **메모리 파편화:** 데이터가 삭제되고 쓰여지는 과정에서 발생하는 메모리 낭비
- **트래픽 급증(Spike):** 이벤트 등으로 인해 갑자기 데이터 유입이 늘어날 경우 대비
- **복제(Replication):** 가용성을 위한 Master-Slave 구조에서의 메모리 점유

# 서버 수 추정 방법론

네, 소프트웨어 설계 단계에서 필요한 서버 수를 추정하는 것은 **용량 산정(Capacity Planning)**의 핵심입니다. 완벽한 정답은 없지만, 서비스의 예상 부하를 바탕으로 논리적인 근거를 만드는 과정이 중요합니다.

일반적으로 다음과 같은 4단계 프로세스를 거쳐 추정합니다.

---

## 1. 요구사항 분석 및 지표 설정

가장 먼저 비즈니스 요구사항을 기술적인 수치로 변환해야 합니다.

- **DAU (Daily Active Users):** 일일 활성 사용자 수
- **평균/최대 RPS (Requests Per Second):** 초당 처리해야 할 요청 수
- **Read/Write 비율:** 읽기 위주의 서비스인지, 쓰기가 많은 서비스인지 파악
- **데이터 보관 기간 및 용량:** DB 서버 산정의 기초

---

## 2. 서버 한 대의 처리 능력(Throughput) 파악

설계 단계라면 유사한 기술 스택의 **벤치마크 데이터**를 참고하거나, 개발 중이라면 **부하 테스트(Load Test)**를 통해 한계를 측정합니다.

- **웹/애플리케이션 서버:** CPU 사용률 70~80% 도달 시점의 RPS
- **데이터베이스 서버:** 쿼리 복잡도에 따른 TPS(Transactions Per Second) 및 메모리 한계

---

## 3. 기본 서버 수 계산 공식

가장 단순화된 계산식은 다음과 같습니다.

$$N = \frac{\text{Total RPS}}{\text{Single Server Capacity (RPS)}} \times \text{Safety Factor}$$

- **Total RPS:** (DAU $\times$ 사용자당 평균 요청 수) / 86,400초. (피크 타임을 고려해 보통 2~5배를 곱함)
- **Safety Factor (안전 계수):** 예상치 못한 트래픽 폭주에 대비해 보통 **1.5 ~ 2배**의 여유를 둡니다.

---

## 4. 아키텍처 관점의 필수 고려 사항

단순 계산 외에 '설계' 관점에서 반드시 추가해야 할 서버들이 있습니다.

| **구분**           | **설명**                                                                                        |
| ------------------ | ----------------------------------------------------------------------------------------------- |
| **고가용성 (HA)**  | 서버 1대가 죽어도 서비스가 유지되도록 최소 **2대 이상(Active-Active 또는 Active-Standby)** 구성 |
| **부하 분산 (LB)** | 트래픽을 나눠줄 로드 밸런서(L4/L7) 배치                                                         |
| **캐시 레이어**    | DB 부하를 줄이기 위한 Redis/Memcached 서버 추가                                                 |
| **데이터베이스**   | 읽기 분산을 위한 Replication(Master-Slave) 구성                                                 |

---

## 5. 실전 예시 (간이 추정)

예를 들어, **DAU 100만 명**인 서비스를 만든다고 가정해 봅시다.

1. **전체 요청량:** 1인당 하루 10번 클릭 시 일일 1,000만 요청.
2. **평균 RPS:** $10,000,000 / 86,400 \approx 115$ RPS.
3. **피크 타임(5배):** 약 600 RPS.
4. **서버 성능:** 서버 한 대가 200 RPS를 견딘다고 가정.
5. **필요 서버 수:** $600 / 200 = 3$대.
6. **최종 산정:** 안전 계수와 HA를 고려하여 **약 4~6대**의 애플리케이션 서버 배치.

# DB서버 수 추정 방법론

소프트웨어 설계 단계에서 DB 서버의 수량과 사양(Spec)을 추정하는 것은 매우 중요하면서도 도전적인 작업입니다. 완벽한 정답은 없지만, **트래픽 분석 → 데이터 모델 분석 → 부하 테스트**의 흐름으로 접근하면 꽤 정교한 예측이 가능합니다.

일반적으로 설계 단계에서 고려해야 할 핵심 요소와 추정 프로세스를 정리해 드립니다.

---

## 1. 주요 추정 지표 (Key Metrics)

DB 스펙을 정하기 위해 먼저 정의해야 할 기초 데이터입니다.

- **TPS (Transactions Per Second):** 초당 처리해야 하는 쿼리 수 (Read/Write 비율 확인).
- **Storage 용량:** 서비스 기간(예: 1~3년) 동안 누적될 데이터의 크기.
- **Active User (DAU/MAU):** 동시 접속자 수와 피크 타임 트래픽.
- **Latency:** 각 요청이 얼마나 빨리 처리되어야 하는지 (예: 100ms 이내).

---

## 2. 사양(Spec) 추정 방법

### CPU: 연산 능력 (TPS 기반)

- **계산법:** `목표 TPS / (코어당 처리 가능한 TPS)`
- 일반적으로 복잡한 Join이나 대량의 Write가 발생할수록 코어 수가 더 많이 필요합니다.
- **Tip:** 보통 초기에는 여유 있게 잡고, 읽기 부하가 높다면 Read Replica를 늘리는 방식으로 대응합니다.

### Memory: 캐싱 및 인덱스 효율

- **기준:** 데이터베이스의 **Working Set**(자주 조회되는 데이터와 인덱스)이 메모리에 다 올라갈 수 있는 크기가 이상적입니다.
- 전체 데이터 크기의 **15~25%** 정도를 메모리로 할당하는 것이 일반적인 권장사항입니다.

### Storage: 용량 및 IOPS

- **용량:** `(Row 크기 * 저장 건수) * (인덱스 오버헤드 1.5~2배) * (로그 및 여유 공간 1.2배)`
- **성능(IOPS):** 쓰기 작업이 많을 경우 HDD보다는 SSD(NVMe)가 필수적이며, 클라우드 환경에서는 프로비저닝된 IOPS 수치를 확인해야 합니다.

---

## 3. 서버 대수 및 아키텍처 결정

단순히 사양만 높이는 것(Scale-up)보다 서버를 어떻게 나눌지(Scale-out) 결정하는 것이 설계의 핵심입니다.

- **HA (High Availability):** 가용성을 위해 최소 **2대(Master-Slave)**는 기본입니다.
- **Read/Write 분리:** 읽기 요청이 많다면 1대의 Master(Write)와 여러 대의 Slave(Read)를 구성합니다.
- **Sharding:** 데이터량이 단일 서버의 한계를 넘어서면 데이터를 여러 서버로 쪼개어 저장(Sharding)하며, 이때 서버 대수는 기하급수적으로 늘어날 수 있습니다.

---

## 4. 실제 추정 예시 (예: 게시판 서비스)

만약 **초당 1,000건의 조회**가 발생하는 게시판을 설계한다면:

1. **Read TPS:** 1,000 TPS
2. **DB 사양:** 단일 인스턴스가 500 TPS를 견딜 수 있다면?
   - **Master 1대:** 쓰기 전용
   - **Slave 2~3대:** 읽기 분산 처리
3. **총 서버 수:** 최소 3~4대의 클러스터 구성 필요
