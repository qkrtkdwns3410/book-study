# 안정 해싱 관점에서 본 DynamoDB와 MySQL의 차이

DynamoDB에서는 안정 해싱을 사용한다고 하는데,  
왜 MySQL에서는 같은 방식의 샤딩이 어렵다고 하는가?

겉으로 보면 두 경우 모두 여러 데이터베이스에 데이터를 나눠 저장하는 것처럼 보인다.  
하지만 이 둘의 차이는 단순히 데이터베이스 개수의 문제가 아니라,  
분산을 누가 책임지느냐, 그리고 데이터베이스가 분산을 인식하고 있는가의 문제다.

---

## 단일 DB와 분산 DB의 근본적인 차이

먼저 “단일 DB”와 “분산 DB”라는 용어부터 명확히 할 필요가 있다.

단일 DB란, 데이터베이스 엔진이 자기 자신만을 독립적인 세계로 인식하는 구조를 말한다.  
MySQL, PostgreSQL 같은 전통적인 RDBMS가 여기에 해당한다.

이들은 다음과 같은 특징을 가진다.

- 자신이 하나의 인스턴스라는 사실만 알고 있다
- 다른 DB 노드의 존재를 알지 못한다
- 데이터가 분산되어 있는지에 대한 개념이 없다
- 어떤 데이터가 어느 DB에 있어야 하는지 판단하지 않는다

즉, MySQL은 “선택된 DB에 대해 SQL을 실행하는 엔진”일 뿐이다.  
여러 개의 MySQL 인스턴스를 띄운다고 해서, 그것이 자동으로 분산 DB가 되지는 않는다.

반면 분산 DB는 처음부터 다르다.  
DynamoDB, Cassandra 같은 시스템은 여러 노드가 하나의 논리적 데이터베이스를 구성한다는 전제를 가진다.

분산 DB는 내부적으로 다음을 알고 있다.

- 전체 노드 목록
- 각 노드의 역할과 상태
- 데이터가 어떤 규칙으로 분산되는지
- 노드 장애 시 어떤 노드가 데이터를 대신 책임지는지

이 차이가 안정 해싱을 사용할 수 있느냐 없느냐를 가르는 결정적인 기준이 된다.

---

## MySQL 샤딩의 본질

MySQL에서 말하는 샤딩은 대부분 애플리케이션 레벨에서 구현된다.

대표적인 방식은 다음과 같다.

- user_id % N 같은 모듈러 샤딩
- ID 범위 기반의 레인지 샤딩
- 샤드 매핑 테이블을 두는 디렉토리 기반 샤딩

이 모든 방식의 공통점은 하나다.

샤드를 결정하는 로직은 애플리케이션에 있고,  
MySQL은 그 결정을 전혀 알지 못한다.

애플리케이션이 “이 요청은 shard2로 가야 한다”고 결정하면,  
MySQL은 그저 shard2에 대해 쿼리를 실행할 뿐이다.

이 구조에서는 다음과 같은 한계가 생긴다.

- 샤드 개수가 바뀌면 데이터 전체를 재배치해야 한다
- 노드 추가·제거에 따른 자동 리밸런싱이 없다
- 장애가 발생해도 DB 차원에서 대체 노드를 선택하지 못한다
- 복제와 샤딩이 느슨하게 결합되어 있다

즉, MySQL에서의 샤딩은 정적 샤딩에 가깝다.  
샤드 수와 분배 규칙이 고정되어 있고, 변경 비용이 매우 크다.

이 때문에 MySQL에서는 안정 해싱의 핵심 장점인  
“노드 증감 시 최소한의 데이터 이동”을 DB 차원에서 구현할 수 없다.

---

## DynamoDB와 안정 해싱

DynamoDB는 설계 단계부터 완전히 다른 접근을 택한다.

DynamoDB는 단일 DB 인스턴스가 아니라,  
분산된 스토리지 노드들의 집합을 하나의 데이터베이스로 추상화한 시스템이다.

여기서 안정 해싱은 단순한 샤딩 기법이 아니라,  
데이터 책임을 분배하는 핵심 규칙으로 사용된다.

DynamoDB 내부에서는 다음과 같은 흐름이 존재한다.

![아마존 서비스 아키텍쳐](https://github.com/gn-book-study/book-study/blob/main/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/members/%EC%9D%B4%EC%A7%80%ED%9B%88/images/aws-architect.png)
그림 : 아마존 서비스 아키텍쳐


![다이나모 파이션 알고리즘](https://github.com/gn-book-study/book-study/blob/main/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/members/%EC%9D%B4%EC%A7%80%ED%9B%88/images/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AA%A8_%ED%8C%8C%ED%8B%B0%EC%85%98.png)
1. 파티션 키를 해시 함수에 통과시킨다
2. 해시 값은 논리적인 해시 링 상의 위치를 결정한다
3. 해당 위치에서 시계 방향으로 가까운 노드들이 데이터를 책임진다
4. 하나의 데이터는 여러 노드에 복제된다
5. 노드가 추가되거나 제거되면, 일부 데이터만 재배치된다

중요한 점은 이 모든 과정이 DB 내부에서 자동으로 처리된다는 것이다.

사용자는 단순히 다음과 같은 인터페이스만 사용한다.

- put(key, value)
- get(key)

데이터가 어느 노드에 저장되는지,  
장애 시 어떤 노드가 대체하는지,  
노드 증설 시 데이터가 어떻게 이동하는지는 전부 DynamoDB의 책임이다.

이 구조 덕분에 DynamoDB는 다음을 자연스럽게 만족한다.

- 노드 추가 시 전체 데이터 재분배 불필요
- 장애 허용성과 고가용성 내장
- 자동 리밸런싱
- 분산 환경에서의 예측 가능한 성능

---

## 왜 MySQL에는 이 구조가 없는가

MySQL도 내부에 안정 해싱과 분산 로직을 넣으면 되는 것 아닌가?

이론적으로는 가능하다.  
하지만 그렇게 되는 순간 MySQL은 더 이상 전통적인 RDBMS가 아니다.

안정 해싱 기반 분산 구조는 다음과 같은 전제를 요구한다.

- 단순한 키 기반 접근
- 조인 최소화 또는 제거
- 분산 트랜잭션의 제약
- 일관성 모델의 선택 (강한 일관성 vs 최종 일관성)

MySQL은 복잡한 조인, 트랜잭션, 스키마 제약을 강점으로 삼는 시스템이다.  
이 특성은 안정 해싱 기반 분산 구조와 본질적으로 긴장 관계에 있다.

그래서 MySQL은 “분산을 아는 DB”가 아니라,  
“분산은 외부에서 해결하는 DB”로 남아 있다.

---

## 정리

MySQL과 DynamoDB의 차이는 단순히 SQL vs NoSQL의 문제가 아니다.  
안정 해싱 관점에서 보면 차이는 더 명확해진다.

- MySQL은 분산을 인식하지 못하는 단일 DB 엔진이다
- DynamoDB는 분산을 전제로 설계된 데이터베이스 시스템이다
- MySQL의 샤딩은 애플리케이션 책임이다
- DynamoDB의 샤딩과 안정 해싱은 DB 내부 책임이다

그래서 MySQL에서는 안정 해싱이 사실상 불가능하고,  
DynamoDB에서는 안정 해싱이 자연스러운 기본 동작이 된다.

이 차이를 이해하면  
샤딩, 안정 해싱, 분산 DB라는 개념들이 서로 다른 이야기가 아니라  
하나의 연속선상에 있다는 것이 보이기 시작한다.

---

## 참고 자료

- AWS DynamoDB Developer Guide – Partitioning and Data Distribution
    +  https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html
- Designing Data-Intensive Applications, Martin Kleppmann
    +  https://parksb.github.io/papers-i-love/dynamo-amazons-highly-available-key-value-store.html
